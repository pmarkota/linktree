"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var deploy_exports = {};
__export(deploy_exports, {
  deploy: () => deploy
});
module.exports = __toCommonJS(deploy_exports);
var import_query_string = require("./utils/query-string");
var import_ready_state = require("./utils/ready-state");
var import_check_deployment_status = require("./check-deployment-status");
var import_utils = require("./utils");
async function* postDeployment(files, clientOptions, deploymentOptions) {
  const debug = (0, import_utils.createDebug)(clientOptions.debug);
  const preparedFiles = (0, import_utils.prepareFiles)(files, clientOptions);
  const apiDeployments = (0, import_utils.getApiDeploymentsUrl)();
  if (deploymentOptions?.builds && !deploymentOptions.functions) {
    clientOptions.skipAutoDetectionConfirmation = true;
  }
  if (deploymentOptions.target === "preview") {
    deploymentOptions.target = void 0;
  }
  if (deploymentOptions.target && deploymentOptions.target !== "production") {
    deploymentOptions.customEnvironmentSlugOrId = deploymentOptions.target;
    deploymentOptions.target = void 0;
  }
  debug("Sending deployment creation API request");
  try {
    const response = await (0, import_utils.fetch)(
      `${apiDeployments}${(0, import_query_string.generateQueryString)(clientOptions)}`,
      clientOptions.token,
      {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ...deploymentOptions,
          files: preparedFiles
        }),
        apiUrl: clientOptions.apiUrl,
        userAgent: clientOptions.userAgent,
        agent: clientOptions.agent
      }
    );
    const deployment = await response.json();
    if (clientOptions.debug) {
      debug("Deployment response:", JSON.stringify(deployment));
    }
    if (!response.ok || deployment.error) {
      debug("Error: Deployment request status is", response.status);
      return yield {
        type: "error",
        payload: deployment.error ? { ...deployment.error, status: response.status } : { ...deployment, status: response.status }
      };
    }
    const indications = /* @__PURE__ */ new Set(["warning", "notice", "tip"]);
    const regex = /^x-(?:vercel|now)-(warning|notice|tip)-(.*)$/;
    for (const [name, payload] of response.headers.entries()) {
      const match = name.match(regex);
      if (match) {
        const [, type, identifier] = match;
        const action = response.headers.get(`x-vercel-action-${identifier}`);
        const link = response.headers.get(`x-vercel-link-${identifier}`);
        if (indications.has(type)) {
          debug(`Deployment created with a ${type}: `, payload);
          yield { type, payload, action, link };
        }
      }
    }
    yield { type: "created", payload: deployment };
  } catch (e) {
    return yield { type: "error", payload: e };
  }
}
function getDefaultName(files, clientOptions) {
  const debug = (0, import_utils.createDebug)(clientOptions.debug);
  const { isDirectory, path } = clientOptions;
  if (isDirectory && typeof path === "string") {
    debug("Provided path is a directory. Using last segment as default name");
    return path.split("/").pop() || path;
  } else {
    debug(
      "Provided path is not a directory. Using last segment of the first file as default name"
    );
    const filePath = Array.from(files.values())[0].names[0];
    return filePath.split("/").pop() || filePath;
  }
}
async function* deploy(files, clientOptions, deploymentOptions) {
  const debug = (0, import_utils.createDebug)(clientOptions.debug);
  if (!deploymentOptions.name) {
    deploymentOptions.version = 2;
    deploymentOptions.name = files.size === 1 ? "file" : getDefaultName(files, clientOptions);
    if (deploymentOptions.name === "file") {
      debug('Setting deployment name to "file" for single-file deployment');
    }
  }
  if (!deploymentOptions.name) {
    deploymentOptions.name = clientOptions.defaultName || getDefaultName(files, clientOptions);
    debug("No name provided. Defaulting to", deploymentOptions.name);
  }
  if (clientOptions.withCache) {
    debug(
      `'withCache' is provided. Force deploy will be performed with cache retention`
    );
  }
  let deployment;
  try {
    debug("Creating deployment");
    for await (const event of postDeployment(
      files,
      clientOptions,
      deploymentOptions
    )) {
      if (event.type === "created") {
        debug("Deployment created");
        deployment = event.payload;
      }
      yield event;
    }
  } catch (e) {
    debug("An unexpected error occurred when creating the deployment");
    return yield { type: "error", payload: e };
  }
  if (deployment) {
    if ((0, import_ready_state.isReady)(deployment) && (0, import_ready_state.isAliasAssigned)(deployment)) {
      debug("Deployment state changed to READY 3");
      yield { type: "ready", payload: deployment };
      debug("Deployment alias assigned");
      return yield { type: "alias-assigned", payload: deployment };
    }
    try {
      debug("Waiting for deployment to be ready...");
      for await (const event of (0, import_check_deployment_status.checkDeploymentStatus)(
        deployment,
        clientOptions
      )) {
        yield event;
      }
    } catch (e) {
      debug(
        "An unexpected error occurred while waiting for deployment to be ready"
      );
      return yield { type: "error", payload: e };
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  deploy
});
