"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var readdir_recursive_exports = {};
__export(readdir_recursive_exports, {
  default: () => readdir
});
module.exports = __toCommonJS(readdir_recursive_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_minimatch = __toESM(require("minimatch"));
function patternMatcher(pattern) {
  return function(path, stats) {
    const minimatcher = new import_minimatch.default.Minimatch(pattern, { matchBase: true });
    return (!minimatcher.negate || stats.isFile()) && minimatcher.match(path);
  };
}
function toMatcherFunction(ignoreEntry) {
  if (typeof ignoreEntry === "function") {
    return ignoreEntry;
  } else {
    return patternMatcher(ignoreEntry);
  }
}
function readdir(path, ignores) {
  ignores = ignores.map(toMatcherFunction);
  let list = [];
  return new Promise(function(resolve, reject) {
    import_fs.default.readdir(path, function(err, files) {
      if (err) {
        return reject(err);
      }
      let pending = files.length;
      if (!pending) {
        return resolve(list);
      }
      files.forEach(function(file) {
        const filePath = import_path.default.join(path, file);
        import_fs.default.lstat(filePath, function(_err, stats) {
          if (_err) {
            return reject(_err);
          }
          const matches = ignores.some((matcher) => matcher(filePath, stats));
          if (matches) {
            pending -= 1;
            if (!pending) {
              return resolve(list);
            }
            return null;
          }
          if (stats.isDirectory()) {
            readdir(filePath, ignores).then(function(res) {
              if (res.length === 0) {
                list.push(filePath);
              }
              list = list.concat(res);
              pending -= 1;
              if (!pending) {
                return resolve(list);
              }
            }).catch(reject);
          } else {
            list.push(filePath);
            pending -= 1;
            if (!pending) {
              return resolve(list);
            }
          }
        });
      });
    });
  });
}
