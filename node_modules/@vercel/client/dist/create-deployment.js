"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var create_deployment_exports = {};
__export(create_deployment_exports, {
  default: () => buildCreateDeployment
});
module.exports = __toCommonJS(create_deployment_exports);
var import_fs_extra = require("fs-extra");
var import_path = require("path");
var import_hashes = require("./utils/hashes");
var import_upload = require("./upload");
var import_utils = require("./utils");
var import_errors = require("./errors");
var import_error_utils = require("@vercel/error-utils");
var import_build_utils = require("@vercel/build-utils");
var import_tar_fs = __toESM(require("tar-fs"));
var import_zlib = require("zlib");
function buildCreateDeployment() {
  return async function* createDeployment(clientOptions, deploymentOptions = {}) {
    const { path } = clientOptions;
    const debug = (0, import_utils.createDebug)(clientOptions.debug);
    debug("Creating deployment...");
    if (typeof path !== "string" && !Array.isArray(path)) {
      debug(
        `Error: 'path' is expected to be a string or an array. Received ${typeof path}`
      );
      throw new import_errors.DeploymentError({
        code: "missing_path",
        message: "Path not provided"
      });
    }
    if (typeof clientOptions.token !== "string") {
      debug(
        `Error: 'token' is expected to be a string. Received ${typeof clientOptions.token}`
      );
      throw new import_errors.DeploymentError({
        code: "token_not_provided",
        message: "Options object must include a `token`"
      });
    }
    clientOptions.isDirectory = !Array.isArray(path) && (0, import_fs_extra.lstatSync)(path).isDirectory();
    if (Array.isArray(path)) {
      for (const filePath of path) {
        if (!(0, import_path.isAbsolute)(filePath)) {
          throw new import_errors.DeploymentError({
            code: "invalid_path",
            message: `Provided path ${filePath} is not absolute`
          });
        }
      }
    } else if (!(0, import_path.isAbsolute)(path)) {
      throw new import_errors.DeploymentError({
        code: "invalid_path",
        message: `Provided path ${path} is not absolute`
      });
    }
    if (clientOptions.isDirectory && !Array.isArray(path)) {
      debug(`Provided 'path' is a directory.`);
    } else if (Array.isArray(path)) {
      debug(`Provided 'path' is an array of file paths`);
    } else {
      debug(`Provided 'path' is a single file`);
    }
    const { fileList } = await (0, import_utils.buildFileTree)(path, clientOptions, debug);
    if (fileList.length === 0) {
      debug("Deployment path has no files. Yielding a warning event");
      yield {
        type: "warning",
        payload: "There are no files inside your deployment."
      };
    }
    const workPath = typeof path === "string" ? path : path[0];
    let files;
    try {
      if (clientOptions.archive === "tgz") {
        debug("Packing tarball");
        const tarStream = import_tar_fs.default.pack(workPath, {
          entries: fileList.map((file) => (0, import_path.relative)(workPath, file))
        }).pipe((0, import_zlib.createGzip)());
        const tarBuffer = await (0, import_build_utils.streamToBuffer)(tarStream);
        debug("Packed tarball");
        files = /* @__PURE__ */ new Map([
          [
            (0, import_hashes.hash)(tarBuffer),
            {
              names: [(0, import_path.join)(workPath, ".vercel/source.tgz")],
              data: tarBuffer,
              mode: 438
            }
          ]
        ]);
      } else {
        files = await (0, import_hashes.hashes)(fileList);
      }
    } catch (err) {
      if (clientOptions.prebuilt && (0, import_error_utils.isErrnoException)(err) && err.code === "ENOENT" && err.path) {
        const errPath = (0, import_path.relative)(workPath, err.path);
        err.message = `File does not exist: "${(0, import_path.relative)(workPath, errPath)}"`;
        if (errPath.split(import_path.sep).includes("node_modules")) {
          err.message = `Please ensure project dependencies have been installed:
${err.message}`;
        }
      }
      throw err;
    }
    debug(`Yielding a 'hashes-calculated' event with ${files.size} hashes`);
    yield { type: "hashes-calculated", payload: (0, import_hashes.mapToObject)(files) };
    if (clientOptions.apiUrl) {
      debug(`Using provided API URL: ${clientOptions.apiUrl}`);
    }
    if (clientOptions.userAgent) {
      debug(`Using provided user agent: ${clientOptions.userAgent}`);
    }
    debug(`Setting platform version to harcoded value 2`);
    deploymentOptions.version = 2;
    debug(`Creating the deployment and starting upload...`);
    for await (const event of (0, import_upload.upload)(files, clientOptions, deploymentOptions)) {
      debug(`Yielding a '${event.type}' event`);
      yield event;
    }
  };
}
