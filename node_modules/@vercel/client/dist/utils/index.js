"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utils_exports = {};
__export(utils_exports, {
  API_FILES: () => API_FILES,
  EVENTS: () => EVENTS,
  buildFileTree: () => buildFileTree,
  createDebug: () => createDebug,
  fetch: () => fetch,
  getApiDeploymentsUrl: () => getApiDeploymentsUrl,
  getVercelIgnore: () => getVercelIgnore,
  parseVercelConfig: () => parseVercelConfig,
  prepareFiles: () => prepareFiles
});
module.exports = __toCommonJS(utils_exports);
var import_node_fetch = __toESM(require("node-fetch"));
var import_path = require("path");
var import_url = require("url");
var import_ignore = __toESM(require("ignore"));
var import_pkg = require("../pkg");
var import_build_utils = require("@vercel/build-utils");
var import_async_sema = require("async-sema");
var import_fs_extra = require("fs-extra");
var import_readdir_recursive = __toESM(require("./readdir-recursive"));
const semaphore = new import_async_sema.Sema(10);
const API_FILES = "/v2/files";
const EVENTS_ARRAY = [
  // File events
  "hashes-calculated",
  "file-count",
  "file-uploaded",
  "all-files-uploaded",
  // Deployment events
  "created",
  "building",
  "ready",
  "alias-assigned",
  "warning",
  "error",
  "notice",
  "tip",
  "canceled",
  // Checks events
  "checks-registered",
  "checks-completed",
  "checks-running",
  "checks-conclusion-succeeded",
  "checks-conclusion-failed",
  "checks-conclusion-skipped",
  "checks-conclusion-canceled"
];
const EVENTS = new Set(EVENTS_ARRAY);
function getApiDeploymentsUrl() {
  return "/v13/deployments";
}
async function parseVercelConfig(filePath) {
  if (!filePath) {
    return {};
  }
  try {
    const jsonString = await (0, import_fs_extra.readFile)(filePath, "utf8");
    return JSON.parse(jsonString);
  } catch (e) {
    console.error(e);
    return {};
  }
}
const maybeRead = async function(path, default_) {
  try {
    return await (0, import_fs_extra.readFile)(path, "utf8");
  } catch (err) {
    return default_;
  }
};
async function buildFileTree(path, {
  isDirectory,
  prebuilt,
  vercelOutputDir
}, debug) {
  const ignoreList = [];
  let fileList;
  let { ig, ignores } = await getVercelIgnore(path, prebuilt, vercelOutputDir);
  debug(`Found ${ignores.length} rules in .vercelignore`);
  debug("Building file tree...");
  if (isDirectory && !Array.isArray(path)) {
    const ignores2 = (absPath) => {
      const rel = (0, import_path.relative)(path, absPath);
      const ignored = ig.ignores(rel);
      if (ignored) {
        ignoreList.push(rel);
      }
      return ignored;
    };
    fileList = await (0, import_readdir_recursive.default)(path, [ignores2]);
    if (prebuilt) {
      const refs = /* @__PURE__ */ new Set();
      const vcConfigFilePaths = fileList.filter(
        (file) => (0, import_path.basename)(file) === ".vc-config.json"
      );
      await Promise.all(
        vcConfigFilePaths.map(async (p) => {
          const configJson = await (0, import_fs_extra.readFile)(p, "utf8");
          const config = JSON.parse(configJson);
          if (!config.filePathMap)
            return;
          for (const v of Object.values(config.filePathMap)) {
            refs.add((0, import_path.join)(path, v));
          }
        })
      );
      if (refs.size > 0) {
        fileList = fileList.concat(Array.from(refs));
      }
    }
    debug(`Found ${fileList.length} files in the specified directory`);
  } else if (Array.isArray(path)) {
    fileList = path;
    debug(`Assigned ${fileList.length} files provided explicitly`);
  } else {
    fileList = [path];
    debug(`Deploying the provided path as single file`);
  }
  return { fileList, ignoreList };
}
async function getVercelIgnore(cwd, prebuilt, vercelOutputDir) {
  const ig = (0, import_ignore.default)();
  let ignores;
  if (prebuilt) {
    if (typeof vercelOutputDir !== "string") {
      throw new Error(
        `Missing required \`vercelOutputDir\` parameter when "prebuilt" is true`
      );
    }
    if (typeof cwd !== "string") {
      throw new Error(`\`cwd\` must be a "string"`);
    }
    const relOutputDir = (0, import_path.relative)(cwd, vercelOutputDir);
    ignores = ["*"];
    const parts = relOutputDir.split(import_path.sep);
    parts.forEach((_, i) => {
      const level = parts.slice(0, i + 1).join("/");
      ignores.push(`!${level}`);
    });
    ignores.push(`!${parts.join("/")}/**`);
    ig.add(ignores.join("\n"));
  } else {
    ignores = [
      ".hg",
      ".git",
      ".gitmodules",
      ".svn",
      ".cache",
      ".next",
      ".now",
      ".vercel",
      ".npmignore",
      ".dockerignore",
      ".gitignore",
      ".*.swp",
      ".DS_Store",
      ".wafpicke-*",
      ".lock-wscript",
      ".env.local",
      ".env.*.local",
      ".venv",
      "npm-debug.log",
      "config.gypi",
      "node_modules",
      "__pycache__",
      "venv",
      "CVS"
    ];
    const cwds = Array.isArray(cwd) ? cwd : [cwd];
    const files = await Promise.all(
      cwds.map(async (cwd2) => {
        const [vercelignore, nowignore] = await Promise.all([
          maybeRead((0, import_path.join)(cwd2, ".vercelignore"), ""),
          maybeRead((0, import_path.join)(cwd2, ".nowignore"), "")
        ]);
        if (vercelignore && nowignore) {
          throw new import_build_utils.NowBuildError({
            code: "CONFLICTING_IGNORE_FILES",
            message: "Cannot use both a `.vercelignore` and `.nowignore` file. Please delete the `.nowignore` file.",
            link: "https://vercel.link/combining-old-and-new-config"
          });
        }
        return vercelignore || nowignore;
      })
    );
    const ignoreFile = files.join("\n");
    ig.add(`${ignores.join("\n")}
${clearRelative(ignoreFile)}`);
  }
  return { ig, ignores };
}
function clearRelative(str) {
  return str.replace(/(\n|^)\.\//g, "$1");
}
const fetch = async (url, token, opts = {}, debugEnabled) => {
  semaphore.acquire();
  const debug = createDebug(debugEnabled);
  let time;
  url = `${opts.apiUrl || "https://api.vercel.com"}${url}`;
  delete opts.apiUrl;
  const { VERCEL_TEAM_ID } = process.env;
  if (VERCEL_TEAM_ID) {
    url += `${url.includes("?") ? "&" : "?"}teamId=${VERCEL_TEAM_ID}`;
  }
  if (opts.teamId) {
    const parsedUrl = new import_url.URL(url);
    parsedUrl.searchParams.set("teamId", opts.teamId);
    url = parsedUrl.toString();
    delete opts.teamId;
  }
  const userAgent = opts.userAgent || `client-v${import_pkg.pkgVersion}`;
  delete opts.userAgent;
  opts.headers = {
    ...opts.headers,
    authorization: `Bearer ${token}`,
    accept: "application/json",
    "user-agent": userAgent
  };
  debug(`${opts.method || "GET"} ${url}`);
  time = Date.now();
  const res = await (0, import_node_fetch.default)(url, opts);
  debug(`DONE in ${Date.now() - time}ms: ${opts.method || "GET"} ${url}`);
  semaphore.release();
  return res;
};
const isWin = process.platform.includes("win");
const prepareFiles = (files, clientOptions) => {
  const preparedFiles = [];
  for (const [sha, file] of files) {
    for (const name of file.names) {
      let fileName;
      if (clientOptions.isDirectory) {
        fileName = typeof clientOptions.path === "string" ? (0, import_path.relative)(clientOptions.path, name) : name;
      } else {
        const segments = name.split(import_path.sep);
        fileName = segments[segments.length - 1];
      }
      preparedFiles.push({
        file: isWin ? fileName.replace(/\\/g, "/") : fileName,
        size: file.data?.byteLength || file.data?.length,
        mode: file.mode,
        sha: sha || void 0
      });
    }
  }
  return preparedFiles;
};
function createDebug(debug) {
  if (debug) {
    return (...logs) => {
      process.stderr.write(
        [`[client-debug] ${(/* @__PURE__ */ new Date()).toISOString()}`, ...logs].join(" ") + "\n"
      );
    };
  }
  return () => {
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  API_FILES,
  EVENTS,
  buildFileTree,
  createDebug,
  fetch,
  getApiDeploymentsUrl,
  getVercelIgnore,
  parseVercelConfig,
  prepareFiles
});
