"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var upload_exports = {};
__export(upload_exports, {
  upload: () => upload
});
module.exports = __toCommonJS(upload_exports);
var import_http = __toESM(require("http"));
var import_https = __toESM(require("https"));
var import_stream = require("stream");
var import_node_events = __toESM(require("node:events"));
var import_async_retry = __toESM(require("async-retry"));
var import_async_sema = require("async-sema");
var import_utils = require("./utils");
var import_errors = require("./errors");
var import_deploy = require("./deploy");
const isClientNetworkError = (err) => {
  if (err.message) {
    return err.message.includes("ETIMEDOUT") || err.message.includes("ECONNREFUSED") || err.message.includes("ENOTFOUND") || err.message.includes("ECONNRESET") || err.message.includes("EAI_FAIL") || err.message.includes("socket hang up") || err.message.includes("network socket disconnected");
  }
  return false;
};
async function* upload(files, clientOptions, deploymentOptions) {
  const { token, teamId, apiUrl, userAgent } = clientOptions;
  const debug = (0, import_utils.createDebug)(clientOptions.debug);
  if (!files && !token && !teamId) {
    debug(`Neither 'files', 'token' nor 'teamId are present. Exiting`);
    return;
  }
  let shas = [];
  debug("Determining necessary files for upload...");
  for await (const event of (0, import_deploy.deploy)(files, clientOptions, deploymentOptions)) {
    if (event.type === "error") {
      if (event.payload.code === "missing_files") {
        shas = event.payload.missing;
        debug(`${shas.length} files are required to upload`);
      } else {
        return yield event;
      }
    } else {
      if (event.type === "alias-assigned") {
        debug("Deployment succeeded on file check");
        return yield event;
      }
      yield event;
    }
  }
  const uploads = shas.map((sha) => {
    return new UploadProgress(sha, files.get(sha));
  });
  yield {
    type: "file-count",
    payload: { total: files, missing: shas, uploads }
  };
  const uploadList = {};
  debug("Building an upload list...");
  const semaphore = new import_async_sema.Sema(50, { capacity: 50 });
  const defaultAgent = apiUrl?.startsWith("https://") ? new import_https.default.Agent({ keepAlive: true }) : new import_http.default.Agent({ keepAlive: true });
  const abortController = new AbortController();
  import_node_events.default.setMaxListeners(50);
  shas.forEach((sha, index) => {
    const uploadProgress = uploads[index];
    uploadList[sha] = (0, import_async_retry.default)(
      async (bail) => {
        const file = files.get(sha);
        if (!file) {
          debug(`File ${sha} is undefined. Bailing`);
          return bail(new Error(`File ${sha} is undefined`));
        }
        await semaphore.acquire();
        const { data } = file;
        if (typeof data === "undefined") {
          return;
        }
        uploadProgress.bytesUploaded = 0;
        const body = new import_stream.Readable();
        const originalRead = body.read.bind(body);
        body.read = function(...args) {
          const chunk = originalRead(...args);
          if (chunk) {
            uploadProgress.bytesUploaded += chunk.length;
            uploadProgress.emit("progress");
          }
          return chunk;
        };
        const chunkSize = 16384;
        for (let i = 0; i < data.length; i += chunkSize) {
          const chunk = data.slice(i, i + chunkSize);
          body.push(chunk);
        }
        body.push(null);
        let err;
        let result;
        try {
          const res = await (0, import_utils.fetch)(
            import_utils.API_FILES,
            token,
            {
              agent: clientOptions.agent || defaultAgent,
              method: "POST",
              headers: {
                "Content-Type": "application/octet-stream",
                "Content-Length": data.length,
                "x-now-digest": sha,
                "x-now-size": data.length
              },
              body,
              teamId,
              apiUrl,
              userAgent,
              // @ts-expect-error: typescript is getting confused with the signal types from node (web & server) and node-fetch (server only)
              signal: abortController.signal
            },
            clientOptions.debug
          );
          if (res.status === 200) {
            debug(
              `File ${sha} (${file.names[0]}${file.names.length > 1 ? ` +${file.names.length}` : ""}) uploaded`
            );
            result = {
              type: "file-uploaded",
              payload: { sha, file }
            };
          } else if (res.status > 200 && res.status < 500) {
            debug(
              `An internal error occurred in upload request. Not retrying...`
            );
            const { error } = await res.json();
            err = new import_errors.DeploymentError(error);
          } else {
            debug(`A server error occurred in upload request. Retrying...`);
            const { error } = await res.json();
            throw new import_errors.DeploymentError(error);
          }
        } catch (e) {
          debug(`An unexpected error occurred in upload promise:
${e}`);
          err = new Error(e);
        }
        semaphore.release();
        if (err) {
          if (isClientNetworkError(err)) {
            debug("Network error, retrying: " + err.message);
            throw err;
          } else {
            debug("Other error, bailing: " + err.message);
            abortController.abort();
            return bail(err);
          }
        }
        return result;
      },
      {
        retries: 5,
        factor: 6,
        minTimeout: 10
      }
    );
  });
  debug("Starting upload");
  while (Object.keys(uploadList).length > 0) {
    try {
      const event = await Promise.race(
        Object.keys(uploadList).map((key) => uploadList[key])
      );
      delete uploadList[event.payload.sha];
      yield event;
    } catch (e) {
      return yield { type: "error", payload: e };
    }
  }
  debug("All files uploaded");
  yield { type: "all-files-uploaded", payload: files };
  try {
    debug("Starting deployment creation");
    for await (const event of (0, import_deploy.deploy)(files, clientOptions, deploymentOptions)) {
      if (event.type === "alias-assigned") {
        debug("Deployment is ready");
        return yield event;
      }
      yield event;
    }
  } catch (e) {
    debug("An unexpected error occurred when starting deployment creation");
    yield { type: "error", payload: e };
  }
}
class UploadProgress extends import_node_events.EventEmitter {
  constructor(sha, file) {
    super();
    this.sha = sha;
    this.file = file;
    this.bytesUploaded = 0;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  upload
});
